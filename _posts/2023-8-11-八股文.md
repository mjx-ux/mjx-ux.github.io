---
layout:     post
title:      JVM-类加载
subtitle:   2023-8-11每日一题
date:       2023-08-11
author:     JunXiang Ma
header-img: img/post-bg-cook.jpg
catalog: true
tags:

    - 每日一题
---

# JVM-类加载

类加载：Class Loading

Java类加载是指在Java程序运行时，将类的字节码从磁盘或其他资源加载到内存对数据的**校验**，**解析**和**初始化**，并在Java虚拟机（JVM）中创建一个对应的Class对象的过程。

## 什么是类加载

类加载（Class Loading）是指在Java程序运行时，将类的字节码从外部存储加载到内存中，并在Java虚拟机（JVM）中生成对应的Class对象的过程。在Java中，类加载是实现动态加载和运行的基础，它允许程序在运行时根据需要加载新的类并使用它们，而不是在编译时就将所有的类都加载进来。

## 类加载的时机

Java中类加载是“懒加载”即什么时候用到就什么时候类加载

1. **首次主动使用类时加载（Initial Active Use）**：当程序**首次使用**某个类时，如果该类尚未类加载，JVM会触发类加载过程。主动使用情况包括：

   1. 用java命令运行主类（启动某个类的main方法）
   2. 创建类的实例（new对象）
   3. 调用访问类的静态成员（成员变量和成员方法）
   4. 使用类的父类（触发某个子类的类加载，会优先触发父类的类加载）
   5. 用Java反射访问类

2. 被动使用类时加载（Passive Use）：当程序被动使用类时，JVM不会主动加载该类，而是在需要的时候才会加载。被动使用情况包括：

   1. 访问类的常量字段（因为常量在编译的时候已经存取调用类的常量池，不需要加载定义常量的类）
   2. 通过子类引用父类的静态字段，不会触发子类初始化
   3. 通过数组定义类的引用，不会触发类初始化
   4. 引用类的金泰常量

3. **显式使用类加载器加载（Explicit Load）：** 通过自定义类加载器显式调用ClassLoader的loadClass方法加载某个类

   

## 类加载的过程

1. 加载（Loading）：类加载器从磁盘、网络或其他资源读取类的字节码数据**（读取的本质是IO的过程）**，并将其转为一个或多个字节数组，然后将这些字节数组转为相对应的Class对象。这个阶段不会执行类的代码，只是将类的描述信息加载到内存中。

2. 连接（Linking）:连接阶段包括以下子阶段

   1. 验证（Verification）：验证字节码是否复合JVM规范和安全要求，以防恶意代码执行
   2. 准备（Preparation）：在类的静态变量所使用的内存区域分配空间，并设置默认值
   3. 解析（Resolution）：将类的符号引用转为直接引用，使类可以正确链接到其他类

3. 初始化（Initialization）：对类的**静态字段赋初值**，**执行静态代码块**，完成类的初始化工作。这个阶段是类加载过程中最费时间的部分，只有在需要初始化的时候才会触发。（初始化阶段是唯一涉及到代码层面的阶段。**在这个阶段，类的结构和静态成员已经完全加载和准备好了，已经可以创建该类型的对象了**）

   

## 类加载器

类加载器（ClassLoader）是Java虚拟机（JVM）的一个重要组件，负责将类的字节码从外部资源加载到内存中，并创建对应的Class对象。

### 分类

1. 根类加载器（Bootstrap Class Loader）：也可以叫引导类加载器、启动类加载器，这是JVM内部的一部分，负责加载Java的核心类，如java.lang包下的Class对象（Object、String、System）在JDK中JRE的lib目录下的所有类都是使用根类加载器的。它是由C++实现的，不是Java代码。它是整个类加载层次的跟，没有父类加载器。
2. 拓展类加载器（Extension Class Loader）：负责加载Java拓展库的类，一般位于\lib\ext目录下。它是由Java代码实现的继承于java.lang.ClassLoader，并且的它的父类是根类加载器。
3. 应用程序类加载器（Application Class Loader）：也被叫做系统类记载其，负责加载应用程序的类，是大多数Java应用程序默认使用的类加载器。它同样是Java代码实现的，继承于java.lang.ClassLoader，并且他的父类是拓展类加载器

除了这三个标准的类加载器，开发者还可以通过继承java.lang.ClassLoader类来实现自定义的类加载器，以实现特定的需求，如实现插件机制、热部署等功能。自定义类加载器可以覆盖父类加载器的加载行为，实现自己的加载逻辑。



## 双亲委派模型

在 Java 中，类加载器遵循一种称为**双亲委派模型**的层次结构。

除了根类加载器（Bootstrap ClassLoader）外，Java当中的每一个类加载器都有一个**逻辑**上的父类（不是Java语法上的继承关系，没有使用extends关键字直接继承）。根类加载器是类加载器层次结构的最顶层。

![image-20230813163248636](http://gitee.com/ma-junxiang-mjx/typora_img/raw/master/202308131632690.png)

```java
// 获取系统类加载器的实例对象
ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
System.out.println(systemClassLoader);
// 获取扩展类加载器的实例对象
ClassLoader parent = systemClassLoader.getParent();
System.out.println(parent);

// sun.misc.Launcher$AppClassLoader@18b4aac2
// sun.misc.Launcher$ExtClassLoader@1b6d3586
// 系统类加载器逻辑关系上"继承了"扩展类加载器
// 系统类加载器和扩展类加载器，它们都是sun.misc.Launcher类中内部类的对象。而且它们都是java.net.URLClassLoader类型的子类对象。因为内部类AppClassLoader和ExtClassLoader都继承了java.net.URLClassLoader
```

### 流程

> 双亲委派模式其实一句话就可以说清楚：任何一个类加载器在接到一个类的加载请求时，都会先让其父类进行加载，只有父类无法加载（或者没有父类）的情况下，才尝试自己加载。

1. 当一个类加载器收到加载类的请求时，它首先不会自己尝试加载该类，而是将请求委托给其父类加载器
2. 父类加载器收到请求后，也会采用相同的方式，将请求继续委托给更上层的类加载器
3. 请求沿着类加载器的层次结构向上传递，直到达到根类加载器。然后根类加载器会尝试开始加载该类型
   1. 如果能够加载，它就加载该类
   2. 如果无法加载，请求将沿着类加载器的层次结构向下传递，直到找到能够加载该类的类加载器
4. 如果所有的类加载器都无法加载该类，那么最初请求加载该类的类加载器会抛出ClassNotFoundException异常

### 好处

1. **避免类的重复加载：** 双亲委派模型可以防止同一个类被多次加载，即使在不同的类加载器中。这是因为子加载器会首先委派给父加载器来尝试加载类，只有在父加载器无法加载的情况下，子加载器才会尝试加载。这确保了在整个类加载器层次结构中，同一个类只会被加载一次，从而避免了类的重复加载问题。
2. **保证类的一致性：** 双亲委派模型确保了不同的类加载器加载同一个类时，得到的是相同的Class对象。这保证了类的一致性，即无论通过哪个加载器加载，同一个类的方法和属性都是相同的，避免了因为不同加载器加载导致的类不一致的问题。
3. **增强安全性：** 双亲委派模型增强了类加载的安全性。系统类库中的类通常由启动类加载器加载，而用户自定义的类通常由应用程序类加载器加载。这样，用户自定义的类不能替换或修改核心类库中的类，从而保护了系统的安全性和稳定性。
4. **防止类冲突：** 双亲委派模型可以避免类的冲突问题。如果每个类加载器都可以加载自己的版本的类，可能会导致不同版本的类在同一虚拟机中出现，从而引发类冲突和不确定性。
5. **模块化和隔离：** 双亲委派模型有助于实现模块化和隔离。不同的类加载器可以创建自己的类加载命名空间，使得每个模块可以独立加载和管理自己的类，从而实现更好的模块化和代码隔离。



## 引用

1.[Java类加载机制 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/25228545)

