---
layout:     post
title:      JVM-GC
subtitle:   2023-08-10每日一题
date:       2023-08-10
author:     JunXiang Ma
header-img: img/the-first.png
catalog:   true
tags:

    - 每日一题
---

# GC(Java垃圾回收机制)

GC：Garbage  Collection

Java 的垃圾回收器并不是特指一种，Java官方本身就提供了很多个GC回收器供用户选择，还有各个Java虚拟机厂商（例如 Azul 的PCG、C4）也自己设计开发了很多优秀的垃圾回收器。

**Stop The World** 也是一个很重要的关键词，它会在任何一种GC算法中发生，其实可以把它理解为JVM GC在清理内存时，整个程序的停顿时间。当 Stop The World 发生时，除GC所需的线程外，所有的线程都进入等待状态，直到 GC 任务完成。每一代的Java垃圾回收器，都把缩减 **Stop The World** 停顿时间作为很重要的目标。



**本文仅以 HotSpot 虚拟机展开，详解它的垃圾回收机制**



## 如何确定是垃圾
### 引用计数算法

引用计数算法就是给对象添加了一个引用计数器，每当有地方引用了它，计数器就加1，引用失效时，计数器就减1。

当触发了内存回收的时候，GC会把引用计数器等于0的找出来，释放掉



这时候就会出现了一个问题：两个对象互相引用，引用计数器的值永远是1，无法确定是否是垃圾了。

```java
static class Test{
    public Test instance;
}

public void run() {
    Test t1 = new Test();
    Test t2 = new Test();
    t1.instance = t2;
    t2.instance = t1;
}
```

引入了另外一种算法



### 可达性分析算法（根搜索算法）

其实不止是Java，C# 也是使用可达性分析算法来判断对象是否存活的，这个算法也可以称之为根搜索算法，也可以叫可达性分析算法

这个算法的基本原理是通过一系列可被作为 **GC Roots** 的根对象来作为起始节点，从这些节点开始，根据引用关系向下搜索，搜索过程的就是一条**引用链（Reference Chain）**，没有在这个链条上面的对象，也就是根节点（GC Roots）通过引用链不可达到这个对象时，就认为这个对象是可以被回收的。



#### 哪些对象可以当作GC Root（根节点）

1. 在虚拟机栈帧中引用的对象：线程调用方法时，使用或产生的参数、局部变量、临时变量等

   ```java
   /**
    * a 是栈帧中的本地变量，当 a = null 时，由于此时 a 充当了 GC Root 的作用，
    * a 与原来指向的实例 new Test() 断开了连接，所以对象会被回收。
    * */
   publicclass Test {
       public static  void main(String[] args) {
   	Test a = new Test();
   	a = null;
       }
   }
   ```

2. 在方法区中，类的引用类型静态变量

   ```java
   /**
    * 当栈帧中的本地变量 a = null 时，
    * 由于 a 原来指向的对象与 GC Root (变量 a) 断开了连接。
    * 所以 a 原来指向的对象会被回收，而由于我们给 s 赋值了变量的引用。
    * s 在此时是类静态属性引用，充当了 GC Root 的作用，它指向的对象依然存活!
    * */
   public class Test {
       public static Test s;
       public static  void main(String[] args) {
   	Test a = new Test();
   	a.s = new Test();
   	a = null;
       }
   }
   ```

3. 本地方法栈中的JNI（被native修饰的方法）引用的对象

4. 在JVM内部的对象：基本数据类型的Clas对象，一些常驻的异常对象（NullPointerException），系统类加载器

5. 所有被synchronized同步锁持有的对象

6. 反映JVM内部情况的JMXBean、JVMTI注册的回调、本地代码缓存等

### 总结

Java目前在用的主流虚拟机，都是采用可达性分析法来判断对象是否可被回收的，它通过若干个根节点组成的集合（GC Roots），向下遍历搜索，遍历的过程就是一条引用链，没有在这个链条上面的对象，是不可能被再次使用的，可以判定为可回收的对象。



## 什么时候会执行GC

当程序创建一个新的对象或者基本类型的数据，内存空间不足时，会触发GC的执行。

不同的垃圾回收器，会有不同的回收策略，但大致可以分为两类：分代回收和局部回收两种策略。

## 如何回收垃圾

### 标记清除算法（Mark Sweep）

首先标记出所有的需要回收的对象，在标记完成后，统一回收掉所有被标记的对象。也可以反过来，标记存活的对象，统一回收未被标记的对象。



### 标记复制算法（Copy）

常规的复制算法，是把内存分成**两块大小相同的空间（1 : 1）**，每次只使用其中一块，当使用中的这块内存用完了，就把**存活**的对象移动到另一块内存中，再把使用过的这块内存空间一次性清理掉。这个做法虽然效率极高，但也浪费了一半的内存空间。

因为大部分对象都在新生带死亡被回收，所以提出了基于常规的复制算法的新的内存空间分配，按照8：1：1的比例来分配内存空间，80%Eden内存空间和10%、10%的Survivor空间。



### 标记整理算法（Mark Compact）

标记清除算法会产生内存碎片，不适合哪些需要大量连续内存空间的场景，而**标记整理算法**，就是在其基础之上，增加了**整理**这个操作，去解决这些内存空间碎片化的问题。而整理就是让所有存活的对象都向内存空间一端移动，然后处理掉边界外的内存。



### 分代收集算法（Generational Garbage Collection）

所有的分代收集算法都是优化垃圾收集性能的策略，都基于两个观察

1.弱分代假说：大多数对象都是朝生夕灭的，简单用一次很快就要失去作用消亡（局部变量和临时变量）

2.强分代假说：对象在垃圾收集后仍然存活，那么它在下一次垃圾收集时仍然存活的概率就更高

#### 新生代（Young Generation）

绝大多数创建的对象都会分配到这，这个区域触发的垃圾回收称之为：Minor GC。

#### 老年代（Old Generation）

对象在新生代周期存活了下来，会被拷贝到这里。通常情况下这个区域的对象要比新生代中的对象多。因为扛过多次新生代GC的对象越难被回收，加上了大的内存空间，发生在老年代的GC次数。这个区域的垃圾回收称之为：Major GC。

##### 空间结构

默认情况下，新生代（Young Generation）、老年代（Old Generation）所占的空间比例是1：2

​	它被分成了三个区域空间：

- 1个Eden空间
- 2个Survivor空间（From Survivor、To Survivor）		

默认情况下，新生代空间分配：**Eden：From：To = 8：1：1**

##### 新生代GC收集的执行顺序

1. 绝大数新创建的对象会放在Eden空间内
2. 在Eden空间执行的**第1次**GC（Minor GC）存活的对象会放到其中一个Survivor空间
3. 之后的每一次Minor GC，都会将Eden和使用的Survivor区域中存活的对象，一次性复制到空闲的Survivor空间，然后清理Eden和使用的Survivor空间
4. Survivor空间占比很小，当空闲区的Survior空间不够存放活下来的对象时，这些对象通过**分配担保机制**直接进入老年代
5. 在以上步骤中国重复n次（n = MaxTenuringThreshold）[年龄阈值设定，默认15] 依旧存活的对象，会被移动到老年代



#### 方法区（Method area）

这个区域主要回收废弃的常量和类型，例如例如常量池里不会再被使用的各种符号引用等。类型信息的回收相对严格，必须符合以下3个条件，才会被回收：

> 1.所有实例被回收
> 2.加载该类的ClassLoader 被回收
> 3.Class 对象无法通过任何途径访问（包括反射）



#### 跨代引用问题

新生代中的对象很有可能会被老年代里的对象所引用，当新生代触发GC的时候，只搜索新生代的区域明显是不够的，还得搜索老年代的对象是否引用了新生代中非 GC Roots 引用链上的对象，来确保正确性。但这样做会带来很大的性能开销。为了解决这个问题，Java定义了一种名为记忆集的抽象的数据结构，用于记录存在跨区域引用的对象指针集合。大多数虚拟机，都采用一种**卡表**（Card Table）的方式实现记忆集，卡表由一个数组组成，每一个元素都对应一个特定大小的内存区域，这个内存区域叫做卡页，，欸一个卡页，可能包含n个存在跨区域引用的对象，这个卡页就会被标识为1。当GC发生的时候，就不需要扫描整个区域了，只需要把这些被标识为1的卡页加入对应区域的 GC Roots 里一起扫描即可。

# 引用

1.[Java性能优化之JVM GC（垃圾回收机制） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/25539690)

