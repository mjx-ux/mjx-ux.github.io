---
layout:     post
title:      JVM-运行时的数据区域
subtitle:   2023-08-14每日一题
date:       2023-08-14
author:     JunXiang Ma
header-img: img/post-bg-cook.jpg
catalog: true
tags:
    - 每日一题
---

# JVM-运行时的数据区域

本文章考虑在Java8下，同时为Hot Spot虚拟机

JVM的运行时数据区，不同虚拟机实现可能略微不同，但都会遵从Java虚拟机规范，Java 8虚拟机规范规定，Java虚拟机所管理的内存将会包括一下几个运行时数据区域：

1. 程序计数器（Program Counter Register）
2. Java虚拟机栈（Java Virtual Machine Stack）
3. 本地方法栈（Native Method Stack）
4. Java堆（Java Heap）
5. 方法区（Method Area）

## 程序计数器（Program Counter Register）

程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。

Java中最小的执行单元是线程，因为虚拟机是多线程的，每一个线程互相抢夺CPU时间片，程序计数器就是存储这些指令去做什么，比如循环、跳转、异常处理等等。



从字节码运行的原理来看，单线程模型下的程序计数器貌似可有可无，字节码解析器会按照顺序将字节码翻译成固定操作，即使遇到分支跳转，也无碍程序正确运行下去。然而，现实中的程序往往是通过多线程协作来完成一个任务的，CPU会为每个线程分配一定的时间片，一个线程在其时间片耗尽之后会挂起，直到它再次获得时间片后才会重新运行。为了确保程序正确运行，线程必须从挂起的地方重新执行。**有了程序计数器，就可以保证在涉及线程上下文切换的情景下，程序依然能够正确无误地运行下去**。

1. 程序计数器是一块内存空间几乎可以忽略不记，也是运行速度最快得区域

2. 在JVM规范中，每一个线程都有自己得程序计数器，是线程私有的，声明周期和线程生命周期保持一致

3. 任何时间一个线程只有一个方法在执行，也就是当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址。如果执行的是native方法，则是未指定值（undefined）

4. 它是程序控制流的指示器，分支，循环，跳转，异常处理，线程恢复等基础功能的根基

5. 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令

6. 它是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域

   

## Java虚拟机栈（Java Virtual Machine Stack）

JVM会给每个线程都分配一个私有的内存空间，称为Java虚拟机栈（Java Virtual Machine Stack）。Java虚拟机栈随着线程的创建而创建，JVM只会对其执行两种操作：方法的栈帧的入栈和出栈。也就是说，Java虚拟机栈是存储栈帧的后进先出队列（LIFO）。

每个方法的执行过程，都会伴随着方法的栈帧的创建、入栈和出栈。栈帧是用来存储局部数据和部分过程结果的数据结构，主要包含 **局部变量表**（Local Variable Table）、**操作数栈**（Operand Stack）、**指向当前方法所属类的运行时常量池的引用**（Runtime Constant Pool Reference）

![img](https://pic2.zhimg.com/80/v2-5e4f9f4bb76dd61559d097377df7f3dd_1440w.webp)

### 局部变量表（LVT）

局部变量表是一个索引从0开始的字节数组，存储了一个方法的所有入参和局部变量。LVT所存储的类型都是编译期可知的，包括基础类型（byte、 char、short、int、long、float、double、boolean）对象引用（reference类型）和returnAddress类型（指向一条字节码指令的地址）

LVT的特点

1. 第0个Slot（槽点）固定存储指向方法所属的this指针
2. 初恋long和double占用2个Slot外，其他类型都只占用1个Slot
3. LVT按照变量的声明顺序进行存储

### 操作数栈（OS）

操作数栈用于在方法运算过程存储中间的运算结果、方法入参和返回结果，它是一个后进先出的队列（对应数据结构上的栈）。JVM提供了对OS出栈和入栈的指令，如load指令输入入栈指令、store指令属于出栈指令。

### 运行时常量池引用（Runtime Constant Pool Reference）

每一个栈帧内都包含一个指向当前方法所属类的运行时常量池引用，也称为**符号引用**（Symbolic Reference），用于在类加载阶段对代码的**动态链接**。动态链接所做的就是根据符号引用所表示名字，转换成方法或变量的实际引用，从而实现**运行时绑定**（Late Binding）



## 本地方法栈（Native Method Stack）

本地方法栈用于管理本地方法的调用，本地方法栈既可以被实现成固定大小，也可以实现成可动态地扩展和收缩，因此在特定的场景下也会抛出StackOverflowError异常和OutOfMemoryError异常。



## Java堆（Java Heap）

Java堆时运行时数据区域中最大的一块，绝大部分对象（包括类实例和数组）都在上面存储。堆是所有线程所共享的，随着JVM的启动而创建。我们通过new创建出来的对象都分配于堆中，而且无序主动释放对象内存，统一由GC进行管理回收（**可以参照JVM-GC文章**）。当堆中没有足够的内存来创建对象时，就会抛出OutOfMemoryError异常。

### 线程本地分配缓冲区（TLAB）

JVM通过一种叫做**线程本地分配缓冲区**（Thread Local Allocation Buffer, TLAB）解决了因为多线程同时创建对象，导致的内存分配和线程安全问题。

TLAB是一个线程私有的内存空间，在线程初始化JVM就会将其分配到Eden Space上。后续，如果线程需要创建对象，JVM就会优先在该线程的TLAB上进行分配，线程之间的TLAB是相互隔离的，从而避免了使用同步锁的机制，提高了效率。



## 方法区（Method Area）

方法区是线程共享的区域，在JVM启动时创建，用于存储类的元信息、静态变量、常量、普通方法的字节码内容。方法区可以被实现成大小固定或可动态扩展和收缩，如果内存空间不满足内存分配要求就会抛出OutOfMemoryError异常。

### 运行时常量池（Runtime Constant Pool）

运行时常量池是属于方法区的一部分，class文件被加载到内存中后，其中的常量池信息（包括符号引用和编译期可知的字面值常量）会被存储到此内存空间。这些信息可通过javap解析class文件查看。



字面值常量：

1. 字符串字面值

2. 用**final**修饰的基础类型成员变量的字面值

3. 由字面值常量相加得到的结果

4. String.intern()方法的返回值会加入运行时常量池

5. 基础类型的包装类型

   

## 总结

JVM为了方便其对Java程序的内存管理，将内存划分成了程序计数器、Java虚拟机栈、本地方法栈、方法区、堆等5个区域，组成了运行时数据区。其中前三者为线程私有，后两者为线程共享。线程共享就意味着会有线程冲突问题，程序运行时对方法区的操作并不频繁，因此可以采用同步锁机制解决。然而，因为每次的对象创建都是在堆上分配内存，如果采用同步锁机制，如此频繁的操作将会导致很大的性能损耗，JVM采用了TLAB技术解决了这个问题。JVM为我们屏蔽了很多底层细节，Java程序员只了解使用`new`创建出来的对象会被分配在堆中、对象的内存由垃圾收集器进行回收等基础的知识貌似也可以满足日常的开发活动。



## 引用

1.[JVM运行时数据区（详解+面试）_jvm运行时会分配哪些内存_glenzhang(ty)的博客-CSDN博客](https://blog.csdn.net/qdzjo/article/details/115741193)

2.[深入解析Java的运行时数据区 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/102431019)
