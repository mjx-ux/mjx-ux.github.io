---
layout:     post
title:      Java-多线程
subtitle:   2023-08-15每日一题
date:       2023-08-15
author:     JunXiang Ma
header-img: img/post-bg-miui6.jpg
catalog: 	  true
tags:
    - 每日一题 
---

# 创建线程有哪几种方式？

1. 继承于Thread重写run方法
2. 实现Runnable接口
3. 实现Callable接口
4. 使用线程池例如使用Executor

## 继承Thread重写run方法

```java
public class Demo1 {
    public static void main(String[] args) {
        // 创建并且启动线程
        new MyThread().start();
    }
}

class MyThread extends Thread {
    @Override
    public void run() {
        // 子类必须重写run方法
        System.out.println(Thread.currentThread().getName() + "线程启动");
    }
}
```

1. 新建一个类MyThread继承与java.lang.Thread类

2. 重写该类MyThread继承父类的run方法

3. 创建该类的MyThread的对象（直接使用无参构造），调用start方法启动线程

   ```java
       public Thread() {
           init(null, null, "Thread-" + nextThreadNum(), 0);
       }
   ```

   

效果：启动了MyThread并且自动调用重写的run方法，直到run方法结束



## 实现Runnable接口

```Java
package com.cskaoyan.review.thread;


public class Demo2 {
    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);
        thread.start();
        
        // new Thread(new MyRunnable()).start();
    }
}

class MyRunnable implements Runnable {
    @Override
    public void run() {
        // 重写run方法
        Thread.currentThread().setName("MyRunnable");
        System.out.println(Thread.currentThread().getName() + "线程启动");
    }
}
```

1. 定义一个子类MyRunnable，实现Runnable接口并重写run方法

2. 创建MyRunnable类的对象，并用这个对象作为Thread类的有参构造的入参

   ```java
   public Thread(Runnable target) {
           init(null, target, "Thread-" + nextThreadNum(), 0);
       }
   ```

3. 调用线程的start方法启动线程



## 实现Callable接口

```java
package com.cskaoyan.review.thread;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;


public class Demo3 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // 创建MyCallable对象
        MyCallable myCallable = new MyCallable();

        // 使用FutureTask类来包装Callable对象
        FutureTask<String> stringFutureTask = new FutureTask<>(myCallable);

        // 使用FutureTask对象作为Thread对象的入参创建并且启动线程
        Thread thread = new Thread(stringFutureTask);
        thread.start();

        // 调用FutureTask对象的get方法来获得线程执行结束后的返回值
        String result = stringFutureTask.get();
        System.out.println(result);
    }
}

class MyCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        Thread.currentThread().setName("MyCallable");
        String name = Thread.currentThread().getName();
        return name;
    }
}
```

1. 定义一个子类MyCallable，实现Callable<V>接口并重写call方法（call方法可以有一个传出的值V）
2. 使用FutureTask类来包装Callable对象，该FutureTask对象封装了Callable对象的call方法的返回值
3. 使用FutureTask对象作为Thread对象的入参创建并且启动线程
4. 调用FutureTask对象的get方法来获得线程执行结束后的返回值

![FutureTask继承图](https://hixiaodong123.oss-cn-hangzhou.aliyuncs.com/typora/202302020103647.png?align=center&padding=true)

## 使用线程池例如使用Executor
